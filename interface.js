// --- Configuration ---
const PALETTES_FILE = 'pallets.json';
const BUTTONS_CONTAINER_ID = 'palette-selector';

/**
 * Maps the nested JSON structure from pallets.json to the flat structure
 * required by the CSS variables in resume.html.
 *
 * @param {object} rawData - The raw top-level object from pallets.json.
 * @returns {Array<object>} A flattened array of palettes with standard keys.
 */
function processPalettes(rawData) {
    // Object.keys gets the top-level names (e.g., "Night Trunk", "Vaporwave Dream")
    return Object.keys(rawData).map(paletteName => {
        const p = rawData[paletteName];
        
        // Return a standard object that matches the CSS variable structure
        return {
            name: paletteName, // Use the top-level key as the button name
            // Map your specific color keys to the four CSS variables:
            primary: p.colors.headerBg.hex,           // Corresponds to --color-primary
            accent: p.colors.sectionAccent.hex,       // Corresponds to --color-accent
            link: p.colors.dateLinkText.hex,          // Corresponds to --color-link
            'highlight-bg': p.colors.highlightBg.hex  // Corresponds to --color-highlight-bg
        };
    });
}

/**
 * Applies the selected color palette to the entire document
 * by setting CSS Custom Properties (CSS Variables).
 *
 * @param {object} palette - The processed palette object containing color hex codes.
 */
function applyPalette(palette) {
    const root = document.documentElement.style;
    
    // Set the main colors using the keys generated by processPalettes
    root.setProperty('--color-primary', palette.primary);
    root.setProperty('--color-accent', palette.accent);
    root.setProperty('--color-link', palette.link);
    root.setProperty('--color-highlight-bg', palette['highlight-bg']); 

    console.log(`Applied palette: ${palette.name}`);
    
    // Optional: Update the header color for the "dark mode" palettes
    // Check if the primary color is dark (e.g., Obsidian Edge, Neon Grid)
    if (palette.primary === '#0D0D0D' || palette.primary === '#000000' || palette.primary === '#1B1B1B') {
        document.querySelector('.header').style.color = 'white';
        document.querySelector('.header-name').style.color = palette.accent;
    } else {
        // Default text color for light headers
        document.querySelector('.header').style.color = 'white';
        document.querySelector('.header-name').style.color = palette.accent;
    }
}

/**
 * Creates and inserts the color palette buttons into the document.
 * @param {Array<object>} palettes - Array of palette objects fetched from JSON.
 */
function createPaletteButtons(palettes) {
    const container = document.getElementById(BUTTONS_CONTAINER_ID);

    if (!container) {
        console.error(`Container element with ID "${BUTTONS_CONTAINER_ID}" not found.`);
        return;
    }

    container.innerHTML = ''; // Clear loading text

    palettes.forEach(palette => {
        const button = document.createElement('button');
        button.textContent = palette.name;
        
        // Tailwind classes for styling
        button.className = 'px-4 py-2 m-1 text-sm font-medium rounded-lg transition-colors duration-200 shadow-sm hover:shadow-md whitespace-nowrap';
        
        // Initial button color set to the palette's link color, with a white background
        button.style.backgroundColor = 'white';
        button.style.color = palette.link;
        button.style.borderColor = palette.link;
        
        // Add click event listener to apply the palette
        button.addEventListener('click', () => {
            applyPalette(palette);
        });

        container.appendChild(button);
    });

    // Automatically apply the first palette on load (Night Trunk)
    if (palettes.length > 0) {
        applyPalette(palettes[0]);
    }
}

/**
 * Main function to fetch the JSON data and initialize the interface.
 */
async function initializeInterface() {
    try {
        // Simple retry logic for fetching JSON data
        const maxRetries = 3;
        let response;
        for (let i = 0; i < maxRetries; i++) {
            response = await fetch(PALETTES_FILE);
            if (response.ok) break;
            // Wait with exponential backoff before retrying
            await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 500));
        }

        if (!response.ok) {
            throw new Error(`Failed to fetch ${PALETTES_FILE}: ${response.status} ${response.statusText}`);
        }

        const rawPalettes = await response.json();
        
        // Process the raw data structure into the usable array
        const palettes = processPalettes(rawPalettes);

        if (palettes.length === 0) {
            throw new Error("No valid color palettes found after processing. Check your pallets.json structure.");
        }

        createPaletteButtons(palettes);

    } catch (error) {
        console.error('Error loading or processing palettes:', error);
        
        const container = document.getElementById(BUTTONS_CONTAINER_ID);
        if(container) {
            container.innerHTML = `<p class="text-red-600 text-sm p-2">Error: Failed to load themes. See console.</p>`;
        }
    }
}

// Start the application once the DOM is fully loaded
document.addEventListener('DOMContentLoaded', initializeInterface);


